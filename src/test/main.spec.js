import * as chai from 'chai';
import chaiAsPromised from 'chai-as-promised';
import SbomGithubAction from "../main/main.js";
import sinon from 'sinon';
import { SbomGitHubActionValidationError } from '../main/utils/errorTypes.js';
chai.use(chaiAsPromised);
chai.should();

function mockCollectArguments(argsToInvalidate) {
    let validArgs = {
        "sn-sbom-user": "username",
        "sn-sbom-password": "password",
        "sn-instance-url": "https://service-now.com/",
        "gh-token": "secret-github-token",
        "provider": "repository",
        "repository": "sample-repository",
        "path": "path/in/repo",
        "gh-account-owner": "github-username",
    }
    return sinon.stub(() =>
        Object.keys(validArgs).filter(key => !argsToInvalidate?.includes(key)).reduce((acc, key) => ({ ...acc, [key]: validArgs[key] }), {}));
}

const sampleCheckedOutJson = { sample: "document" };
const SN_INSTANCE = "https://www.mocked-servicenow-instance.com/"
const UPLOAD_API_PATH = "/api/mock/upload/path"

describe('main.js',  () => {

    afterEach(() => {
        sinon.restore();
    })

    describe('#Providers', () => {

        describe('Repository', () => {
            const repositoryInputArgs = {
                token: "secret-github-token",
                repository: "sample-repository",
                path: "path/in/repo",
                ghAccountOwner: "github-username"
            };
            let mockedAction;

            before(() => {
                mockedAction = new SbomGithubAction();
                let mockedRepositoryProvider = sinon.stub();
                mockedRepositoryProvider.withArgs({
                    token: sinon.match.defined,
                    repository: sinon.match.defined,
                    path: sinon.match.defined,
                    ghAccountOwner: sinon.match.defined
                }).returns(sampleCheckedOutJson);
                mockedRepositoryProvider.returns(undefined);
                mockedAction._fetchRepositorySBOM = mockedRepositoryProvider;
            });

            it('Valid arguments', () => {
                let results = mockedAction.repository(repositoryInputArgs);
                results.should.eventually.deep.equal(sampleCheckedOutJson);
            });

            ["token", "repository", "path", "ghAccountOwner"].forEach(paramToInvalidate => {
                let invalidRepositoryInputs =
                    Object.entries(repositoryInputArgs)
                        .filter(([key, _]) => paramToInvalidate !== key)
                        .reduce((acc, cur) => ({ ...acc, [cur[0]]: cur[1] }), {})
                it(`Invalid arguments: Missing ${paramToInvalidate}`, async () => {
                    let results = await mockedAction.repository(invalidRepositoryInputs);
                    (typeof results).should.equal('undefined')
                })
            })


        })
    })

    describe('#Arguments', () => {
        describe('Valid arguments', () => {
            it('All valid arguments', () => {
                let mockedCollectArguments = mockCollectArguments();
                let mockedAction = new SbomGithubAction();
                mockedAction.collectArguments = mockedCollectArguments;
                let results = mockedAction.collectArguments()
                results.should.have.property("sn-sbom-user").eql("username");
                results.should.have.property("sn-sbom-password").eql("password");
                results.should.have.property("sn-instance-url").eql("https://service-now.com/");
                results.should.have.property("gh-token").eql("secret-github-token");
                results.should.have.property("provider").eql("repository");
                results.should.have.property("repository").eql("sample-repository");
                results.should.have.property("path").eql("path/in/repo");
                results.should.have.property("gh-account-owner").eql("github-username");
            })
        })
        describe('Invalid arguments', () => {
            it('Missing sn-sbom-user', () => { // A test to check helper function is valid
                let mockedCollectArguments = mockCollectArguments(['sn-sbom-user']);
                let mockedAction = new SbomGithubAction();
                mockedAction.collectArguments = mockedCollectArguments;
                let results = mockedAction.collectArguments()
                results.should.not.have.property("sn-sbom-user").eql("username");
            });

            describe('Assert all required parameters fail validation if missing', () => {
                const commonRequiredParameters = ["sn-sbom-user", "provider", "sn-sbom-password", "sn-instance-url"];
                const repositoryProviderTypeRequiredParameters = ["gh-account-owner", "repository", "path", "gh-token"];
                ["repository"].forEach(providerType => { // NOTE: Upload me in the future when additional providers are added.
                    let providerTypeSpecificParameters = providerType === "repository" ? repositoryProviderTypeRequiredParameters : [];
                    const allRequiredParameters = [...commonRequiredParameters, ...providerTypeSpecificParameters];

                    describe(`Provider Type: ${providerType}`, () => {
                        allRequiredParameters.forEach((requiredParameter, idx) => {
                            it(`Fails validation Check: ${requiredParameter}`, async () => { // A test to check if a required property is missing, validation fails
                                let mockedCollectArguments = mockCollectArguments([requiredParameter]);
                                let mockedAction = new SbomGithubAction();
                                mockedAction.collectArguments = mockedCollectArguments;
                                await mockedAction.main().catch(error => {
                                    error.should.be.an.instanceOf(SbomGitHubActionValidationError)
                                    error.validationErrors.should.satisfy(validationErrors => validationErrors.some(obj => obj.params.missingProperty === requiredParameter))
                                })
                            })
                        })
                    })
                });
            })
        })

        describe('Upload API arguments', () => {

            let mockedGenerateSbomWorkspaceUrls, mockedAction, baseUrl, requestUrl;
            beforeEach(() => {
                mockedAction = new SbomGithubAction();
                mockedGenerateSbomWorkspaceUrls = sinon.stub();
                mockedGenerateSbomWorkspaceUrls.withArgs({ //snInstanceUrl, apiPath, uploadOptions
                    snInstanceUrl: sinon.match(SN_INSTANCE),
                    apiPath: sinon.match(UPLOAD_API_PATH),
                    uploadOptions: sinon.match.defined,
                })
                baseUrl = new URL(SN_INSTANCE);
                requestUrl = new URL(UPLOAD_API_PATH, baseUrl);
            });

            afterEach(() => sinon.restore());

            it('Adds search parameters to upload API request', async () => {
                let uploadOptions = { businessApplicationId: "business-app-id-123" }
                Object.keys(uploadOptions).filter(key => uploadOptions[key]).forEach(key => requestUrl.searchParams.append(key, uploadOptions[key]));
                mockedGenerateSbomWorkspaceUrls.returns(requestUrl);
                mockedAction._generateSbomWorkspaceUrls = mockedGenerateSbomWorkspaceUrls;
                let sbomGithubAction = new SbomGithubAction();
                let actual = sbomGithubAction._generateSbomWorkspaceUrls({ snInstanceUrl: SN_INSTANCE, apiPath: UPLOAD_API_PATH, uploadOptions })
                let expected = mockedAction._generateSbomWorkspaceUrls({ snInstanceUrl: SN_INSTANCE, apiPath: UPLOAD_API_PATH, uploadOptions })
                actual.href.should.eql(expected.href);
            })

            it('Fails on invalid option value', () => {
                let uploadOptions = { lifecycleStage: "pre-production" }
                Object.keys(uploadOptions).filter(key => uploadOptions[key]).forEach(key => requestUrl.searchParams.append(key, uploadOptions[key]));
                mockedGenerateSbomWorkspaceUrls.returns(requestUrl);
                mockedAction._generateSbomWorkspaceUrls = mockedGenerateSbomWorkspaceUrls;
                let sbomGithubAction = new SbomGithubAction();
                let actual = sbomGithubAction._generateSbomWorkspaceUrls({ snInstanceUrl: SN_INSTANCE, apiPath: UPLOAD_API_PATH, uploadOptions })
                let expected = mockedAction._generateSbomWorkspaceUrls({ snInstanceUrl: SN_INSTANCE, apiPath: UPLOAD_API_PATH, uploadOptions })
                actual.href.should.eql(expected.href);
            })
        })
    })

    describe('#Upload', () => {

        const uploadInputArgs = {
            document: sampleCheckedOutJson,
            snInstanceUrl: "https://service-now.com/",
            snUsername: "username",
            snPassword: "password"
        }
        const successfulUploadResponseBody = {
            "result": {
                "status": "success",
                "message": "Queued for processing.",
                "bomRecordId": "b44a32f48776c610c9ca0d07cebb35c0"
            }
        }
        let mockedAction;

        beforeEach(() => {
           let uploadMock = sinon.stub();
           uploadMock.withArgs({
               document: sinon.match.any,
               snInstanceUrl: sinon.match.any,
               snUsername: sinon.match.any,
               snPassword: sinon.match.any,
           }).resolves(successfulUploadResponseBody);
           uploadMock.resolves({});
           mockedAction = new SbomGithubAction();
           mockedAction.upload = uploadMock;
        });

        it('Valid arguments', async () => {
            let results = await mockedAction.upload(uploadInputArgs);
            results.result.should.have.ownProperty('status');
            results.result.status.should.equal('success');
        });

        ["document", "snInstanceUrl", "snUsername", "snPassword"].forEach(paramToInvalidate => {
            let invalidRepositoryInputs =
                Object.entries(uploadInputArgs)
                    .filter(([key, _]) => paramToInvalidate !== key)
                    .reduce((acc, cur) => ({ ...acc, [cur[0]]: cur[1] }), {})
            it(`Invalid arguments: Missing ${paramToInvalidate}`, async () => {
                let results = mockedAction.repository(invalidRepositoryInputs);
                results.should.eventually.eql({});
            })
        })
    })
});