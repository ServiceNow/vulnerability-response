import core from '@actions/core';
import {validateInputArguments} from './utils/validator.js';
import {PROVIDER_TYPES, LOG_GROUP_STAGES} from './utils/constants.js';
import {checkout} from './utils/checkout.js';
import dotenv from "dotenv";
dotenv.config();

export default class SbomGithubAction {

    constructor() {
        this.activeGroup = String();
        this.numPolls = 0
    }

    /**
     * @description This function executes the SBOM Workspace GitHub Action Sequence.
     * @note The action expects arguments to either come aggregated or non-aggregated. When the `args` input is asserted, its values are prioritized. Otherwise, the expected input structure is recreated for validation purposes.
     */
    async main() {
        try {
            let args = this.collectArguments()
            this.activeGroup = LOG_GROUP_STAGES.VALIDATING_ARGUMENTS;
            validateInputArguments(args);

            let documents, errorMessage;
            switch (args.provider) { // Allows for easily extending to more provider options.
                case PROVIDER_TYPES.REPOSITORY:
                    documents = await this.repository(args);
                    break;

                case PROVIDER_TYPES.REMOTE:
                    this.activeGroup = LOG_GROUP_STAGES.FETCHING_DOCUMENT_REMOTE;
                    errorMessage = "Current version (v1.0.0) does not support remote provider type.";

                default:
                    errorMessage = errorMessage ?? `Unsupported provider type observed (${args.provider}).`
                    throw new Error(errorMessage);

            }

            this.activeGroup = LOG_GROUP_STAGES.UPLOADING_DOCUMENT;
            const uploadOptions = {
                documents,
                snInstanceUrl: args['sn-instance-url'],
                snUsername: args['sn-sbom-user'],
                snPassword: args['sn-sbom-password']
            };
            let response = await this.upload(uploadOptions);
            core.startGroup(this.activeGroup);
            if (response.result.status !== "success") {
                console.error("Could not enqueue document. If needed, validate document:");
                console.error(JSON.stringify(document, null, 2));
                core.setFailed(`Upload request responded with unsuccessful status: ${JSON.stringify(response, null, 2)}`);
                core.endGroup();
                return;
            }
            core.endGroup();

            await core.summary
                .addHeading('Upload Queue Results', '2')
                .addQuote('✅ Successfully enqueued!')
                .addTable([
                    [{ data: 'Status', header: true}, { data: 'Message', header: true }, { data: 'BOM Record ID', header: true }],
                    [
                        { data: String((status => status.charAt(0) + status.slice(1))(response.result.status)) }, // Capitalize first character
                        { data: String(response.result.message) },
                        { data: String(response.result.bomRecordId) }
                    ]
                ])
                .write();

            let status = await this.pollStatus({...uploadOptions, bomRecordId: response.result.bomRecordId});
            let componentSummary = status.result?.uploadSummary?.components;
            if(componentSummary) {
                await core.summary
                    .addHeading('Upload Status Results', '2')
                    .addQuote('✅ Successfully processed!')
                    .addHeading('Component Summary', '3')
                    .addTable([
                        [{ data: 'Added', header: true }, { data: 'Removed', header: true }, { data: 'Total', header: true }],
                        [{ data: String(componentSummary.added) }, { data: String(componentSummary.removed) }, { data: String(componentSummary.total) }]
                    ])
                    .write();
            } else if(this.numPolls !== 5) {
                core.warning('Enqueuing of SBOM was success; however, processing was not successful.');
            } else {
                core.info('Maximum number of polls reached. Please review status within SBOM Workspace.');
            }

        } catch (error) {
            if (process.env.NODE_ENV !== 'test') {
                core.startGroup(`Error while in stage: ${this.activeGroup}`);
                core.setFailed(error.message);
                core.endGroup();
            }
            throw error;
        }
    }

    /**
     * Assembles the requisite input arguments provided to the GitHub Action.
     * @returns {*} An object of secret and public arguments.
     */
    collectArguments() {
        const secretParameters = ['sn-sbom-user', 'sn-sbom-password', 'sn-instance-url', 'gh-token'];
        const secrets = secretParameters.reduce((acc, arg) => ({...acc, [arg]: core.getInput(arg)}), {});
        const publicParameters = ['provider', 'repository', 'path', 'gh-account-owner'];
        const parameters = publicParameters.reduce((acc, arg) => ({...acc, [arg]: core.getInput(arg)}), {});
        return {...secrets, ...parameters}
    }

    /**
     * Performs the upload to the SBOM Workspace.
     * @param document
     * @param snInstanceUrl
     * @param snUsername
     * @param snPassword
     * @returns {Promise<any>}
     */
    async upload({documents, snInstanceUrl, snUsername, snPassword}) {

        console.log("documents: ", JSON.stringify({ documents }, null, 2))

        let uploadUrl = this._generateSbomWorkspaceUrls({snInstanceUrl, apiPath: '/api/sbom/core/upload'})

        let uploadPromises = documents.map(document =>
            fetch(uploadUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Basic ${Buffer.from(snUsername + ":" + snPassword).toString('base64')}`
                },
                body: JSON.stringify(document)
            })
                .then(response => response.json())
                .then(data => data)
                .catch(error => {
                    core.warning(`An error occurred while uploading SBOM: ${error.message}`)
                    throw error;
                })
        )

        console.log(await Promise.all(uploadPromises).then(data => data.map(response => response)))
    }

    _generateSbomWorkspaceUrls({snInstanceUrl, apiPath}) {
        let baseUrl = new URL(snInstanceUrl);
        return new URL(apiPath, baseUrl);
    }

    /**
     * A helper function to initialize arguments for fetching of repository based SBOM document.
     * @param args
     * @returns {Promise<*>} When resolved, the document from the target repository.
     */
    async repository(args) {
        this.activeGroup = LOG_GROUP_STAGES.FETCHING_DOCUMENT_REPOSITORY;
        const repository_args = {
            token: args['gh-token'],
            repository: args['repository'],
            path: args['path'],
            ghAccountOwner: args['gh-account-owner'],
        };
        core.startGroup(this.activeGroup);
        console.log(`Repository arguments: ${JSON.stringify(repository_args, null, 2)}`);
        core.endGroup();
        return await this._fetchRepositorySBOM(repository_args);
    }

    /**
     * Checks out the provider GitHub repository and returns the specified SBOM document.
     * @returns {Promise<*>} The SBOM document pointed to by the configured file path.
     */
    async _fetchRepositorySBOM({token, repository, path, ghAccountOwner}) {
        // Clone repository contents
        const checkoutOptions = {
            token,
            repo: repository,
            path: path,
            owner: ghAccountOwner
        }

        // Only perform checkout if all required inputs are provided
        if (Object.values(checkoutOptions).reduce((acc, cur) => acc && (cur !== undefined), true)) {
            return await checkout(checkoutOptions);
        }
    }

    async pollStatus({bomRecordId, snInstanceUrl, snUsername, snPassword}) {
        this.activeGroup = LOG_GROUP_STAGES.POLLING_STATUS;
        let statusUrl = this._generateSbomWorkspaceUrls({snInstanceUrl, apiPath: '/api/sbom/core/upload/status'})
        statusUrl.searchParams.append('bomRecordId', bomRecordId);
        core.startGroup(this.activeGroup);

        let pollingComplete = false, pollingData = [];

        const doPoll = async () => {
            return fetch(statusUrl, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Basic ${Buffer.from(snUsername + ":" + snPassword).toString('base64')}`
                }
            })
                .then(response => response.json())
                .then(data => {
                    if(data.result.uploadStatus === 'processed') {
                        pollingComplete = true;
                    }
                    return data;
                })
                .catch(error => {
                    core.warning(`An error occurred while polling the status of upload: ${error}`)
                    throw error;
                })
        }

        while (this.numPolls < 5 && !pollingComplete) {
            await Promise.all([
                doPoll().then(data => pollingData.push(data)),
                new Promise(resolve => setTimeout(resolve, 5000))
            ]);
            this.numPolls++;
        }

        return pollingData.pop();
    }
}

if(process.env.NODE_ENV !== 'test') {
    let action = new SbomGithubAction();
    await action.main();
}