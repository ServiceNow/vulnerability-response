import core from '@actions/core';
import {validateInputArguments} from './utils/validator.js';
import {PROVIDER_TYPES, LOG_GROUP_STAGES} from './utils/constants.js';
import {checkout} from './utils/checkout.js';
import dotenv from "dotenv";
dotenv.config();

export default class SbomGithubAction {

    constructor() {
        this.activeGroup = String();
    }

    /**
     * @description This function executes the SBOM Workspace GitHub Action Sequence.
     * @note The action expects arguments to either come aggregated or non-aggregated. When the `args` input is asserted, its values are prioritized. Otherwise, the expected input structure is recreated for validation purposes.
     */
    async main() {
        try {
            let args = this.collectArguments()
            this.activeGroup = LOG_GROUP_STAGES.VALIDATING_ARGUMENTS;
            validateInputArguments(args);

            let document, errorMessage;
            switch (args.provider) { // Allows for easily extending to more provider options.
                case PROVIDER_TYPES.REPOSITORY:
                    document = await this.repository(args);
                    break;

                case PROVIDER_TYPES.REMOTE:
                    this.activeGroup = LOG_GROUP_STAGES.FETCHING_DOCUMENT_REMOTE;
                    errorMessage = "Current version (v1.0.0) does not support remote provider type.";

                default:
                    errorMessage = errorMessage ?? `Unsupported provider type observed (${args.provider}).`
                    throw new Error(errorMessage);

            }

            this.activeGroup = LOG_GROUP_STAGES.UPLOADING_DOCUMENT;
            const uploadOptions = {
                document,
                snInstanceUrl: args['sn-instance-url'],
                snUsername: args['sn-sbom-user'],
                snPassword: args['sn-sbom-password']
            };
            let response = await this.upload(uploadOptions);
            core.startGroup(this.activeGroup);
            console.log(JSON.stringify(response, null, 2));
            if (response.result.status !== "success") {
                console.error("Could not enqueue document. If needed, validate document:");
                console.error(JSON.stringify(document, null, 2));
                core.setFailed(`Upload request responded with unsuccessful status: ${JSON.stringify(response, null, 2)}`);
                core.endGroup();
                return;
            }
            core.endGroup();

            await core.summary
                .addHeading('Upload Queue Results')
                .addCodeBlock(JSON.stringify(response, null, 2), 'js')
                .write();

            let status = await this.pollStatus({...uploadOptions, bomRecordId: response.result.bomRecordId});
            console.log(JSON.stringify(status, null, 2));
            let componentSummary = status.result?.uploadSummary?.components;
            console.log(JSON.stringify(componentSummary, null, 2));
            if(componentSummary) {
                await core.summary
                    .addHeading('Upload Status Results', '3')
                    .addQuote('âœ… Successfully processed!')
                    .addTable([
                        [{ data: 'Added', header: true }, { data: 'Removed', header: true }, { data: 'Total', header: true }],
                        [{ data: String(componentSummary.added) }, { data: String(componentSummary.removed) }, { data: String(componentSummary.total) }]
                    ])
                    .addDetails('Response', JSON.stringify(status, null, 2))
                    .write();
            }

        } catch (error) {
            if (process.env.NODE_ENV !== 'test') {
                core.startGroup(`Error while in stage: ${this.activeGroup}`);
                core.setFailed(error.message);
                core.endGroup();
            }
            throw error;
        }
    }

    /**
     * Assembles the requisite input arguments provided to the GitHub Action.
     * @returns {*} An object of secret and public arguments.
     */
    collectArguments() {
        const secretParameters = ['sn-sbom-user', 'sn-sbom-password', 'sn-instance-url', 'gh-token'];
        const secrets = secretParameters.reduce((acc, arg) => ({...acc, [arg]: core.getInput(arg)}), {});
        const publicParameters = ['provider', 'repository', 'path', 'gh-account-owner'];
        const parameters = publicParameters.reduce((acc, arg) => ({...acc, [arg]: core.getInput(arg)}), {});
        return {...secrets, ...parameters}
    }

    /**
     * Performs the upload to the SBOM Workspace.
     * @param document
     * @param snInstanceUrl
     * @param snUsername
     * @param snPassword
     * @returns {Promise<any>}
     */
    async upload({document, snInstanceUrl, snUsername, snPassword}) {
        let uploadUrl = this._generateSbomWorkspaceUrls({snInstanceUrl, apiPath: '/api/sbom/core/upload'})

        return await fetch(uploadUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Basic ${Buffer.from(snUsername + ":" + snPassword).toString('base64')}`
            },
            body: JSON.stringify(document)
        })
            .then(response => response.json())
            .then(data => data)
            .catch(error => {
                console.log(error);
                throw error;
            })
    }

    _generateSbomWorkspaceUrls({snInstanceUrl, apiPath}) {
        let baseUrl = new URL(snInstanceUrl);
        return new URL(apiPath, baseUrl);
    }

    /**
     * A helper function to initialize arguments for fetching of repository based SBOM document.
     * @param args
     * @returns {Promise<*>} When resolved, the document from the target repository.
     */
    async repository(args) {
        this.activeGroup = LOG_GROUP_STAGES.FETCHING_DOCUMENT_REPOSITORY;
        const repository_args = {
            token: args['gh-token'],
            repository: args['repository'],
            path: args['path'],
            ghAccountOwner: args['gh-account-owner'],
        };
        core.startGroup(this.activeGroup);
        console.log(`Repository arguments: ${JSON.stringify(repository_args, null, 2)}`);
        core.endGroup();
        return await this._fetchRepositorySBOM(repository_args);
    }

    /**
     * Checks out the provider GitHub repository and returns the specified SBOM document.
     * @returns {Promise<*>} The SBOM document pointed to by the configured file path.
     */
    async _fetchRepositorySBOM({token, repository, path, ghAccountOwner}) {
        // Clone repository contents
        const checkoutOptions = {
            token,
            repo: repository,
            path: path,
            owner: ghAccountOwner
        }

        // Only perform checkout if all required inputs are provided
        if (Object.values(checkoutOptions).reduce((acc, cur) => acc && (cur !== undefined), true)) {
            return await checkout(checkoutOptions);
        }
    }

    async pollStatus({bomRecordId, snInstanceUrl, snUsername, snPassword}) {
        this.activeGroup = LOG_GROUP_STAGES.POLLING_STATUS;
        let statusUrl = this._generateSbomWorkspaceUrls({snInstanceUrl, apiPath: '/api/sbom/core/upload/status'})
        statusUrl.searchParams.append('bomRecordId', bomRecordId);
        core.startGroup(this.activeGroup);

        let intervalId, numPolls = 0, pollingComplete = false, pollingData = [];

        const doPoll = async () => {
            return fetch(statusUrl, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Basic ${Buffer.from(snUsername + ":" + snPassword).toString('base64')}`
                }
            })
                .then(response => response.json())
                .then(data => {
                    if(data.result.uploadStatus === 'processed') {
                        pollingComplete = true;
                    }
                    return data;
                })
                .catch(error => {
                    console.log(error);
                    clearTimeout(intervalId);
                    throw error;
                })
        }

        while (numPolls < 5 && !pollingComplete) {
            await Promise.all([
                doPoll().then(data => pollingData.push(data)),
                new Promise(resolve => setTimeout(resolve, 5000))
            ]);
            numPolls++;
        }

        console.log(pollingData.map(d => JSON.stringify(d, null, 2)))
        return pollingData.pop();
    }
}

if(process.env.NODE_ENV != 'test') {
    let action = new SbomGithubAction();
    await action.main();
}