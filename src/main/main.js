import core from '@actions/core';
import {validateInputArguments} from './utils/validator.js';
import {PROVIDER_TYPES, LOG_GROUP_STAGES} from './utils/constants.js';
import {checkout} from './utils/checkout.js';
import dotenv from "dotenv";
dotenv.config();
import fetch from 'node-fetch';

export default class SbomGithubAction {

    constructor() {
        this.activeGroup = String();
    }

    /**
     * @description This function executes the SBOM Workspace GitHub Action Sequence.
     * @note The action expects arguments to either come aggregated or non-aggregated. When the `args` input is asserted, its values are prioritized. Otherwise, the expected input structure is recreated for validation purposes.
     */
    async main() {
        try {
            let args = this.collectArguments()
            this.activeGroup = LOG_GROUP_STAGES.VALIDATING_ARGUMENTS;
            validateInputArguments(args);

            let githubObjects, errorMessage;
            switch (args.provider) {
                case PROVIDER_TYPES.REPOSITORY:
                    githubObjects = await this.repository(args);
                    break;

                case PROVIDER_TYPES.REMOTE:
                    this.activeGroup = LOG_GROUP_STAGES.FETCHING_DOCUMENT_REMOTE;
                    errorMessage = "Current version (v1.0.0) does not support remote provider type.";

                default:
                    errorMessage = errorMessage ?? `Unsupported provider type observed (${args.provider}).`
                    throw new Error(errorMessage);

            }

            this.activeGroup = LOG_GROUP_STAGES.UPLOADING_DOCUMENT;
            const uploadOptions = {
                githubObjects,
                uploadOptions: {
                    businessApplicationId: args['business-application-id'],
                    businessApplicationName: args['business-application-name'],
                    buildId: args['build-id'],
                    productModelId: args['product-model-id'],
                    requestedBy: args['requested-by'],
                    lifecycleStage: args['lifecycle-stage'],
                    fetchVulnerabilityInfo: args['fetch-vulnerability-info'],
                    fetchPackageInfo: args['fetch-package-info'],
                    sourceSbom: args['source-sbom']
                },
                snInstanceUrl: args['sn-instance-url'],
                snUsername: args['sn-sbom-user'],
                snPassword: args['sn-sbom-password'],
            };
            let responses = await this.upload(uploadOptions);

            if(responses === undefined) {
                core.setFailed("Could not successfully enqueue SBOM for processing.")
                return
            }

            core.startGroup(this.activeGroup);

            let successfulResponses = responses.filter(({ data }) => data.result.status === 'success')
            let unsuccessfulResponses = responses.filter(({ data }) => data.result.status !== 'success')
            let uploadQueueResults = [...successfulResponses, ...unsuccessfulResponses];

            let processingDidFail = false;
            if(unsuccessfulResponses.length > 0) {
                let { data, file_name } = unsuccessfulResponses[0];
                processingDidFail = true;
                core.setFailed(`Failed to process ${file_name}: ${data.result.message}`);
            }

            let uploadQueueRows = uploadQueueResults.map(({ data, file_name }) => [
                { data: String(file_name) },
                { data: String((status => status.charAt(0).toUpperCase() + status.slice(1))(data.result.status)) }, // Capitalize first character
                { data: String(data.result.message) },
                { data: String(data.result.bomRecordId) }
            ])
            core.endGroup();

            await core.summary
                .addHeading('Upload Queue Results', '2')
                .addQuote(processingDidFail ? "⚠️ SBOM failed processing." : "✅ Successfully enqueued!")
                .addTable([
                    [{ data: 'Name', header: true } , { data: 'Status', header: true}, { data: 'Message', header: true }, { data: 'BOM Record ID', header: true }],
                    ...uploadQueueRows
                ])
                .write();

        } catch (error) {
            if (process.env.NODE_ENV !== 'test') {
                core.startGroup(`Error while in stage: ${this.activeGroup}`);
                core.setFailed(error.message);
                core.endGroup();
            }
            throw error;
        }
    }

    /**
     * Assembles the requisite input arguments provided to the GitHub Action.
     * @returns {*} An object of secret and public arguments.
     */
    collectArguments() {
        const secretParameters = [ 'sn-sbom-user', 'sn-sbom-password', 'sn-instance-url', 'gh-token' ];
        const secrets = secretParameters.reduce((acc, arg) => ({...acc, [arg]: core.getInput(arg)}), {});
        const publicParameters = [ 'provider', 'repository', 'path', 'gh-account-owner' ];
        const parameters = publicParameters.reduce((acc, arg) => ({...acc, [arg]: core.getInput(arg)}), {});
        const uploadApiParameters = [
            'business-application-id',
            'business-application-name',
            'product-model-id',
            'requested-by',
            'build-id',
            'lifecycle-stage',
            'fetch-vulnerability-info',
            'fetch-package-info',
            'source-sbom'
        ];
        const uploadApiArguments = uploadApiParameters.reduce((acc, arg) => ({...acc, [arg]: core.getInput(arg)}), {});
        return { ...secrets, ...parameters, ...uploadApiArguments };
    }

    /**
     * Performs the upload to the SBOM Workspace.
     * @param document
     * @param snInstanceUrl
     * @param snUsername
     * @param snPassword
     * @returns {Promise<any>}
     */
    async upload({githubObjects, snInstanceUrl, snUsername, snPassword, uploadOptions}) {
        let uploadUrl = this._generateSbomWorkspaceUrls({snInstanceUrl, apiPath: '/api/sbom/core/upload', uploadOptions});

        console.log(uploadUrl.href)

        let uploadPromises = githubObjects.map(({ document, file_name }) =>
            fetch(uploadUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Basic ${Buffer.from(snUsername + ":" + snPassword).toString('base64')}`
                },
                body: JSON.stringify(document)
            })
                .then(response => response.json())
                .then(data => ({
                    data, file_name
                }))
                .catch(error => {
                    core.warning(`An error occurred while uploading SBOM: ${error.message}`)
                    throw error;
                })
        )

        return await Promise.all(uploadPromises)
            .then(data => data.map(response => response))
            .catch(error => console.error(error));
    }

    /**
     * Generate URL for SBOM Upload API
     * @param snInstanceUrl The ServiceNow instance URL
     * @param apiPath The resource path within the API
     * @param uploadOptions The options added to the query string
     * @returns {URL} The generated URL for POST
     * @private
     */
    _generateSbomWorkspaceUrls({snInstanceUrl, apiPath, uploadOptions}) {
        let baseUrl = new URL(snInstanceUrl);
        let requestUrl = new URL(apiPath, baseUrl);
        Object.keys(uploadOptions).filter(key => uploadOptions[key]).forEach(key => requestUrl.searchParams.append(key, uploadOptions[key]));
        return requestUrl;
    }

    /**
     * A helper function to initialize arguments for fetching of repository based SBOM document.
     * @param args
     * @returns {Promise<*>} When resolved, the document from the target repository.
     */
    async repository(args) {
        this.activeGroup = LOG_GROUP_STAGES.FETCHING_DOCUMENT_REPOSITORY;
        const repository_args = {
            token: args['gh-token'],
            repository: args['repository'],
            path: args['path'],
            ghAccountOwner: args['gh-account-owner'],
        };
        core.startGroup(this.activeGroup);
        console.log(`Repository arguments: ${JSON.stringify(repository_args, null, 2)}`);
        core.endGroup();
        return await this._fetchRepositorySBOM(repository_args);
    }

    /**
     * Checks out the provider GitHub repository and returns the specified SBOM document.
     * @returns {Promise<*>} The SBOM document pointed to by the configured file path.
     */
    async _fetchRepositorySBOM({token, repository, path, ghAccountOwner}) {
        // Clone repository contents
        const checkoutOptions = {
            token,
            repo: repository,
            path: path,
            owner: ghAccountOwner
        }

        // Only perform checkout if all required inputs are provided
        if (Object.values(checkoutOptions).reduce((acc, cur) => acc && (cur !== undefined), true)) {
            return await checkout(checkoutOptions);
        }
    }
}

if(process.env.NODE_ENV !== 'test') {
    let action = new SbomGithubAction();
    await action.main();
}