import {
  ActionArguments,
  StatusApiResponseBody,
  UploadApiResponseBody,
  UploadApiResponseObject
} from '@/src/types/action'
import { REQUEST_STATUS_ERROR_INSUFFICIENT_DATA } from '@/src/types/errors'
import * as core from '@actions/core'
import { writeToSummary } from '@/src/utils/summary'

export function generateStatusUrl(actionArguments: ActionArguments, bomRecordId: string) {
  let statusSearchParams = new URLSearchParams()
  statusSearchParams.append('bomRecordId', bomRecordId)
  let url = new URL('/api/sbom/core/upload/status', actionArguments.secrets.snInstanceUrl)
  url.search = statusSearchParams.toString()
  return url
}

function _onStatusPollEnded(history: StatusApiResponseBody[]) {
  console.log('history: ', history)
}

export async function status(actionArguments: ActionArguments, uploadOperationResponseObject: UploadApiResponseObject) {
  if (uploadOperationResponseObject.data.result.bomRecordId == undefined) {
    throw new Error(REQUEST_STATUS_ERROR_INSUFFICIENT_DATA('Missing bomRecordId').message)
  }

  let statusUrl = generateStatusUrl(actionArguments, uploadOperationResponseObject.data.result.bomRecordId!)
  let numPolls = 0,
    MAX_NUM_POLLS = 5
  let pollHistory: StatusApiResponseBody[] = []

  function endPolling(intervalId: ReturnType<typeof setTimeout>, pollHistory: StatusApiResponseBody[]) {
    clearInterval(intervalId)
    _onStatusPollEnded(pollHistory)
  }

  console.log('Polling status...')
  await core.summary.addHeading('SBOM Processing Status').write()
  let intervalId = setInterval(async () => {
    if (numPolls++ < MAX_NUM_POLLS) {
      let results = await _performStatus(
        statusUrl,
        actionArguments.secrets.snSbomUser,
        actionArguments.secrets.snSbomPassword
      )
      pollHistory.push(results)
      writeToSummary(String(numPolls))
      if (results.result.uploadStatus === 'processed') {
        endPolling(intervalId, pollHistory)
      } else {
        console.log(`Polling status... (retrying ${numPolls}/${MAX_NUM_POLLS})`)
      }
    } else {
      endPolling(intervalId, pollHistory)
    }
  }, 5000)
}

export async function _performStatus(
  statusUrl: URL,
  snSbomUser: string,
  snSbomPassword: string
): Promise<StatusApiResponseBody> {
  return await fetch(statusUrl, {
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Basic ${Buffer.from(snSbomUser + ':' + snSbomPassword).toString('base64')}`
    }
  })
    .then(response => response.json())
    .then(data => data)
    .catch(error => {
      core.warning(`An error occurred while retrieving status of SBOM: ${error.message}`)
      throw error
    })
}
