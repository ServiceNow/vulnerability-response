import {
  ActionArguments,
  FetchedSbomDocument,
  UploadApiResponseBody,
  UploadApiResponseObject
} from '@/src/types/action'

import core from '@actions/core'
import * as uploadUtils from './upload'

export function generateUploadUrl(actionArguments: ActionArguments) {
  let { sbomRestApiUploadArguments } = actionArguments
  let uploadSearchParams = new URLSearchParams()
  Object.entries(sbomRestApiUploadArguments ?? {})
    .filter(([_, value]) => !!value)
    .forEach(([key, value]) => {
      uploadSearchParams.append(key, value)
    })

  let url = new URL('/api/sbom/core/upload', actionArguments.secrets.snInstanceUrl)
  url.search = uploadSearchParams.toString()
  return url
}

export async function upload(actionArguments: ActionArguments, payload: FetchedSbomDocument) {
  let uploadUrl = generateUploadUrl(actionArguments)
  let { snSbomUser, snSbomPassword } = actionArguments.secrets

  let uploadOperationResponseObject = await uploadUtils._performUpload(
    uploadUrl,
    snSbomUser,
    snSbomPassword,
    payload.document,
    payload.documentName,
    payload.type
  )
  await core.summary.addHeading('Test').write()
  return uploadOperationResponseObject
}

export async function _performUpload(
  uploadUrl: URL,
  snSbomUser: string,
  snSbomPassword: string,
  document: any,
  documentName: string,
  documentType: 'spdx' | 'cyclonedx'
) {
  return await fetch(uploadUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Basic ${Buffer.from(snSbomUser + ':' + snSbomPassword).toString('base64')}`
    },
    body: JSON.stringify(document)
  })
    .then(response => response.json())
    .then(
      data =>
        ({
          data: data as UploadApiResponseBody,
          documentName: documentName
        }) as UploadApiResponseObject
    )
    .catch(error => {
      core.warning(`An error occurred while uploading SBOM: ${error.message}`)
      throw error
    })
}
