/******/ var __webpack_modules__ = ({

/***/ 146:
/***/ ((module) => {

module.exports = eval("require")("@actions/core");


/***/ }),

/***/ 204:
/***/ ((module) => {

module.exports = eval("require")("@actions/github");


/***/ }),

/***/ 841:
/***/ ((module) => {

module.exports = eval("require")("ajv");


/***/ }),

/***/ 40:
/***/ ((module) => {

module.exports = eval("require")("dotenv");


/***/ }),

/***/ 566:
/***/ ((module) => {

module.exports = eval("require")("node-fetch");


/***/ }),

/***/ 390:
/***/ ((__webpack_module__, __webpack_exports__, __nccwpck_require__) => {

__nccwpck_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ SbomGithubAction)
/* harmony export */ });
/* harmony import */ var _actions_core__WEBPACK_IMPORTED_MODULE_0__ = __nccwpck_require__(146);
/* harmony import */ var _utils_validator_js__WEBPACK_IMPORTED_MODULE_1__ = __nccwpck_require__(858);
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __nccwpck_require__(248);
/* harmony import */ var _utils_checkout_js__WEBPACK_IMPORTED_MODULE_3__ = __nccwpck_require__(943);
/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_4__ = __nccwpck_require__(40);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_5__ = __nccwpck_require__(566);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_utils_validator_js__WEBPACK_IMPORTED_MODULE_1__]);
_utils_validator_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





dotenv__WEBPACK_IMPORTED_MODULE_4__.config();


class SbomGithubAction {

    constructor() {
        this.activeGroup = String();
    }

    /**
     * @description This function executes the SBOM Workspace GitHub Action Sequence.
     * @note The action expects arguments to either come aggregated or non-aggregated. When the `args` input is asserted, its values are prioritized. Otherwise, the expected input structure is recreated for validation purposes.
     */
    async main() {
        try {
            let args = this.collectArguments()
            this.activeGroup = _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .LOG_GROUP_STAGES.VALIDATING_ARGUMENTS */ .D.VALIDATING_ARGUMENTS;
            (0,_utils_validator_js__WEBPACK_IMPORTED_MODULE_1__/* .validateInputArguments */ .h)(args);

            let githubObjects, errorMessage;
            switch (args.provider) {
                case _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .PROVIDER_TYPES.REPOSITORY */ .h.REPOSITORY:
                    githubObjects = await this.repository(args);
                    break;

                case _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .PROVIDER_TYPES.REMOTE */ .h.REMOTE:
                    this.activeGroup = _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .LOG_GROUP_STAGES.FETCHING_DOCUMENT_REMOTE */ .D.FETCHING_DOCUMENT_REMOTE;
                    errorMessage = "Current version (v1.0.0) does not support remote provider type.";

                default:
                    errorMessage = errorMessage ?? `Unsupported provider type observed (${args.provider}).`
                    throw new Error(errorMessage);

            }

            this.activeGroup = _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .LOG_GROUP_STAGES.UPLOADING_DOCUMENT */ .D.UPLOADING_DOCUMENT;
            const uploadOptions = {
                githubObjects,
                uploadOptions: {
                    businessApplicationId: args['business-application-id'],
                    businessApplicationName: args['business-application-name'],
                    buildId: args['build-id'],
                    productModelId: args['product-model-id'],
                    requestedBy: args['requested-by'],
                    lifecycleStage: args['lifecycle-stage'],
                    fetchVulnerabilityInfo: args['fetch-vulnerability-info'],
                    fetchPackageInfo: args['fetch-package-info'],
                    sourceSbom: args['source-sbom']
                },
                snInstanceUrl: args['sn-instance-url'],
                snUsername: args['sn-sbom-user'],
                snPassword: args['sn-sbom-password'],
            };
            let responses = await this.upload(uploadOptions);

            if(responses === undefined) {
                _actions_core__WEBPACK_IMPORTED_MODULE_0__.setFailed("Could not successfully enqueue SBOM for processing.")
                return
            }

            _actions_core__WEBPACK_IMPORTED_MODULE_0__.startGroup(this.activeGroup);

            let successfulResponses = responses.filter(({ data }) => data.result.status === 'success')
            let unsuccessfulResponses = responses.filter(({ data }) => data.result.status !== 'success')
            let uploadQueueResults = [...successfulResponses, ...unsuccessfulResponses];

            let processingDidFail = false;
            if(unsuccessfulResponses.length > 0) {
                let { data, file_name } = unsuccessfulResponses[0];
                processingDidFail = true;
                _actions_core__WEBPACK_IMPORTED_MODULE_0__.setFailed(`Failed to process ${file_name}: ${data.result.message}`);
            }

            let uploadQueueRows = uploadQueueResults.map(({ data, file_name }) => [
                { data: String(file_name) },
                { data: String((status => status.charAt(0).toUpperCase() + status.slice(1))(data.result.status)) }, // Capitalize first character
                { data: String(data.result.message) },
                { data: String(data.result.bomRecordId) }
            ])
            _actions_core__WEBPACK_IMPORTED_MODULE_0__.endGroup();

            await _actions_core__WEBPACK_IMPORTED_MODULE_0__.summary.addHeading('Upload Queue Results', '2')
                .addQuote(processingDidFail ? "⚠️ SBOM failed processing." : "✅ Successfully enqueued!")
                .addTable([
                    [{ data: 'Name', header: true } , { data: 'Status', header: true}, { data: 'Message', header: true }, { data: 'BOM Record ID', header: true }],
                    ...uploadQueueRows
                ])
                .write();

        } catch (error) {
            if (process.env.NODE_ENV !== 'test') {
                _actions_core__WEBPACK_IMPORTED_MODULE_0__.startGroup(`Error while in stage: ${this.activeGroup}`);
                _actions_core__WEBPACK_IMPORTED_MODULE_0__.setFailed(error.message);
                _actions_core__WEBPACK_IMPORTED_MODULE_0__.endGroup();
            }
            throw error;
        }
    }

    /**
     * Assembles the requisite input arguments provided to the GitHub Action.
     * @returns {*} An object of secret and public arguments.
     */
    collectArguments() {
        const secretParameters = [ 'sn-sbom-user', 'sn-sbom-password', 'sn-instance-url', 'gh-token' ];
        const secrets = secretParameters.reduce((acc, arg) => ({...acc, [arg]: _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput(arg)}), {});
        const publicParameters = [ 'provider', 'repository', 'path', 'gh-account-owner' ];
        const parameters = publicParameters.reduce((acc, arg) => ({...acc, [arg]: _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput(arg)}), {});
        const uploadApiParameters = [
            'business-application-id',
            'business-application-name',
            'product-model-id',
            'requested-by',
            'build-id',
            'lifecycle-stage',
            'fetch-vulnerability-info',
            'fetch-package-info',
            'source-sbom'
        ];
        const uploadApiArguments = uploadApiParameters.reduce((acc, arg) => ({...acc, [arg]: _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput(arg)}), {});
        return { ...secrets, ...parameters, ...uploadApiArguments };
    }

    /**
     * Performs the upload to the SBOM Workspace.
     * @param document
     * @param snInstanceUrl
     * @param snUsername
     * @param snPassword
     * @returns {Promise<any>}
     */
    async upload({githubObjects, snInstanceUrl, snUsername, snPassword, uploadOptions}) {
        let uploadUrl = this._generateSbomWorkspaceUrls({snInstanceUrl, apiPath: '/api/sbom/core/upload', uploadOptions});

        let uploadPromises = githubObjects.map(({ document, file_name }) =>
            node_fetch__WEBPACK_IMPORTED_MODULE_5__(uploadUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Basic ${Buffer.from(snUsername + ":" + snPassword).toString('base64')}`
                },
                body: JSON.stringify(document)
            })
                .then(response => response.json())
                .then(data => ({
                    data, file_name
                }))
                .catch(error => {
                    _actions_core__WEBPACK_IMPORTED_MODULE_0__.warning(`An error occurred while uploading SBOM: ${error.message}`)
                    throw error;
                })
        )

        return await Promise.all(uploadPromises)
            .then(data => data.map(response => response))
            .catch(error => console.error(error));
    }

    /**
     * Generate URL for SBOM Upload API
     * @param snInstanceUrl The ServiceNow instance URL
     * @param apiPath The resource path within the API
     * @param uploadOptions The options added to the query string
     * @returns {URL} The generated URL for POST
     * @private
     */
    _generateSbomWorkspaceUrls({snInstanceUrl, apiPath, uploadOptions}) {
        let baseUrl = new URL(snInstanceUrl);
        let requestUrl = new URL(apiPath, baseUrl);
        Object.keys(uploadOptions).filter(key => uploadOptions[key]).forEach(key => requestUrl.searchParams.append(key, uploadOptions[key]));
        return requestUrl;
    }

    /**
     * A helper function to initialize arguments for fetching of repository based SBOM document.
     * @param args
     * @returns {Promise<*>} When resolved, the document from the target repository.
     */
    async repository(args) {
        this.activeGroup = _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .LOG_GROUP_STAGES.FETCHING_DOCUMENT_REPOSITORY */ .D.FETCHING_DOCUMENT_REPOSITORY;
        const repository_args = {
            token: args['gh-token'],
            repository: args['repository'],
            path: args['path'],
            ghAccountOwner: args['gh-account-owner'],
        };
        _actions_core__WEBPACK_IMPORTED_MODULE_0__.startGroup(this.activeGroup);
        console.log(`Repository arguments: ${JSON.stringify(repository_args, null, 2)}`);
        _actions_core__WEBPACK_IMPORTED_MODULE_0__.endGroup();
        return await this._fetchRepositorySBOM(repository_args);
    }

    /**
     * Checks out the provider GitHub repository and returns the specified SBOM document.
     * @returns {Promise<*>} The SBOM document pointed to by the configured file path.
     */
    async _fetchRepositorySBOM({token, repository, path, ghAccountOwner}) {
        // Clone repository contents
        const checkoutOptions = {
            token,
            repo: repository,
            path: path,
            owner: ghAccountOwner
        }

        // Only perform checkout if all required inputs are provided
        if (Object.values(checkoutOptions).reduce((acc, cur) => acc && (cur !== undefined), true)) {
            return await (0,_utils_checkout_js__WEBPACK_IMPORTED_MODULE_3__/* .checkout */ .J)(checkoutOptions);
        }
    }
}

if(process.env.NODE_ENV !== 'test') {
    let action = new SbomGithubAction();
    await action.main();
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ 943:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   "J": () => (/* binding */ checkout)
/* harmony export */ });
/* harmony import */ var _actions_github__WEBPACK_IMPORTED_MODULE_0__ = __nccwpck_require__(204);
/* harmony import */ var _actions_core__WEBPACK_IMPORTED_MODULE_1__ = __nccwpck_require__(146);



/**
 * Checks out the SBOM document at a given path within the supplied repository.
 * @param token The GitHub token for the provider repository.
 * @param repo The name of the provider GitHub repository.
 * @param path The absolute path to the SBOM document from the root of the provider GitHub repository.
 * @param owner The name of the owner of the provider GitHub repository.
 */
async function checkout({token, owner, repo, path}) {
    const gh = _actions_github__WEBPACK_IMPORTED_MODULE_0__.getOctokit(token);
    const resp = await gh.request(`GET /repos/{owner}/{repo}/contents/{path}`, {
        owner, path, repo, headers: {
            'X-GitHub-Api-Version': '2022-11-28',
            'Accept': 'application/vnd.github.object+json'
        }
    });

    if(resp.status !== 200) {
        console.error(resp);
        _actions_core__WEBPACK_IMPORTED_MODULE_1__.setFailed('Unsuccessful attempt to checkout GitHub repository.');
        throw new Error('Unsuccessful attempt to checkout GitHub repository.');
    }
    const type = resp.data.type;

    let downloadUrls, fileMetadata;
    if(type === 'dir') {
        _actions_core__WEBPACK_IMPORTED_MODULE_1__.setFailed('SBOM Workspace GitHub Action presently only supports uploading individual files one at a time.');
        return;
    } else {
        if(!resp.data.name.endsWith('.json')) {
            throw new Error('Only JSON files are supported.');
        }
        fileMetadata = [{
            download_url: resp.data.download_url,
            file_name: resp.data.name
        }]
        downloadUrls = [ resp.data.download_url ];
    }

    let fetchPromises = downloadUrls.map((contentUrl, idx) =>
        fetch(contentUrl)
            .then(response => response.json())
            .then(document => ({
                document,
                file_name: fileMetadata[idx]?.file_name ?? String()
            }))
    );

    let responses = await Promise.all(fetchPromises)
        .then(documents => documents);

    if(responses.length === 0) {
        _actions_core__WEBPACK_IMPORTED_MODULE_1__.setFailed(`No SBOM files identified at the following path: ${owner}/${repo}/${path}`);
        throw new Error(`No SBOM files identified at the following path: ${owner}/${repo}/${path}`);
    }

    return responses
}

/***/ }),

/***/ 248:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   "D": () => (/* binding */ LOG_GROUP_STAGES),
/* harmony export */   "h": () => (/* binding */ PROVIDER_TYPES)
/* harmony export */ });
const PROVIDER_TYPES = Object.freeze({
    REPOSITORY: 'repository',   // Currently supported
    PAYLOAD: 'payload',         // Not supported in current version
    REMOTE: 'remote'            // Not supported in current version
});

const LOG_GROUP_STAGES = Object.freeze({
    VALIDATING_ARGUMENTS: "Validating input arguments",
    FETCHING_DOCUMENT_REPOSITORY: "Fetching SBOM from repository",
    FETCHING_DOCUMENT_REMOTE: "Fetching SBOM from remote",
    UPLOADING_DOCUMENT: "Uploading SBOM document to ServiceNow",
    POLLING_STATUS: "Polling status of enqueued document"
});



/***/ }),

/***/ 522:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   "e": () => (/* binding */ SbomGitHubActionValidationError)
/* harmony export */ });
class SbomGitHubActionValidationError extends Error {
    constructor(message, errors) {
        super(message);
        if(process.env.NODE_ENV !== 'test')
            console.error(`AJV Validation Error: ${JSON.stringify({errors}, null, 2)}`);
        this.name = this.constructor.name;
        this.validationErrors = errors;
        Error.captureStackTrace(this, this.constructor);
    }
}

/***/ }),

/***/ 625:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

/* unused harmony export validatableSchemas */
const validatableSchemas = Object.freeze({
    DIRECT: 0,
    AGGREGATED: 1
});

/***/ }),

/***/ 858:
/***/ ((__webpack_module__, __webpack_exports__, __nccwpck_require__) => {

__nccwpck_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ validateInputArguments)
/* harmony export */ });
/* unused harmony export validateDocument */
/* harmony import */ var _schema_schemaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __nccwpck_require__(625);
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_1__ = __nccwpck_require__(841);
/* harmony import */ var _errorTypes_js__WEBPACK_IMPORTED_MODULE_2__ = __nccwpck_require__(522);
// import aggregatedInputSchema from './schema/aggregatedInputs.json' with { type: "json" };
// import directInputSchema from './schema/directInputs.json' with { type: "json" };
const { default: directInputSchema } = await __nccwpck_require__.e(/* import() */ 363).then(__nccwpck_require__.t.bind(__nccwpck_require__, 363, 17));


const ajv = new ajv__WEBPACK_IMPORTED_MODULE_1__();


function validateInputArguments(args) {
    let validate = ajv.compile(directInputSchema);
    const valid = validate(args);
    if (!valid) {
        throw new _errorTypes_js__WEBPACK_IMPORTED_MODULE_2__/* .SbomGitHubActionValidationError */ .e(`An error occurred while validating the input arguments: ${JSON.stringify(args, null, 2)}`, validate.errors);
    }
}

async function validateSpdxDocument(document, version) {
    return true;
}

async function validateCyclonedxDocument(document, version) {
    return true;
}

async function validateDocument(document) {
    const type = Object.hasOwn(document, "bomFormat") ? "CycloneDX" :
        (Object.hasOwn(document, "SPDXID") ? "SPDX" : undefined);
    if(type === undefined) { throw new Error('Invalid SBOM document type provided. SBOM Workspace only accepts the SPDX and CycloneDX specifications.'); }
    const version = type === "CycloneDX" ? document.specVersion : document.spdxVersion;
    const isValid = type === "CycloneDX" ?
        await validateCyclonedxDocument(document, version) :
        await validateSpdxDocument(document, version);
    return isValid;
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nccwpck_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	var threw = true;
/******/ 	try {
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 		threw = false;
/******/ 	} finally {
/******/ 		if(threw) delete __webpack_module_cache__[moduleId];
/******/ 	}
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __nccwpck_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/async module */
/******/ (() => {
/******/ 	var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 	var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 	var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 	var resolveQueue = (queue) => {
/******/ 		if(queue && !queue.d) {
/******/ 			queue.d = 1;
/******/ 			queue.forEach((fn) => (fn.r--));
/******/ 			queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 		}
/******/ 	}
/******/ 	var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 		if(dep !== null && typeof dep === "object") {
/******/ 			if(dep[webpackQueues]) return dep;
/******/ 			if(dep.then) {
/******/ 				var queue = [];
/******/ 				queue.d = 0;
/******/ 				dep.then((r) => {
/******/ 					obj[webpackExports] = r;
/******/ 					resolveQueue(queue);
/******/ 				}, (e) => {
/******/ 					obj[webpackError] = e;
/******/ 					resolveQueue(queue);
/******/ 				});
/******/ 				var obj = {};
/******/ 				obj[webpackQueues] = (fn) => (fn(queue));
/******/ 				return obj;
/******/ 			}
/******/ 		}
/******/ 		var ret = {};
/******/ 		ret[webpackQueues] = x => {};
/******/ 		ret[webpackExports] = dep;
/******/ 		return ret;
/******/ 	}));
/******/ 	__nccwpck_require__.a = (module, body, hasAwait) => {
/******/ 		var queue;
/******/ 		hasAwait && ((queue = []).d = 1);
/******/ 		var depQueues = new Set();
/******/ 		var exports = module.exports;
/******/ 		var currentDeps;
/******/ 		var outerResolve;
/******/ 		var reject;
/******/ 		var promise = new Promise((resolve, rej) => {
/******/ 			reject = rej;
/******/ 			outerResolve = resolve;
/******/ 		});
/******/ 		promise[webpackExports] = exports;
/******/ 		promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 		module.exports = promise;
/******/ 		body((deps) => {
/******/ 			currentDeps = wrapDeps(deps);
/******/ 			var fn;
/******/ 			var getResult = () => (currentDeps.map((d) => {
/******/ 				if(d[webpackError]) throw d[webpackError];
/******/ 				return d[webpackExports];
/******/ 			}))
/******/ 			var promise = new Promise((resolve) => {
/******/ 				fn = () => (resolve(getResult));
/******/ 				fn.r = 0;
/******/ 				var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 				currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 			});
/******/ 			return fn.r ? promise : getResult();
/******/ 		}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 		queue && (queue.d = 0);
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/create fake namespace object */
/******/ (() => {
/******/ 	var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 	var leafPrototypes;
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 16: return value when it's Promise-like
/******/ 	// mode & 8|1: behave like require
/******/ 	__nccwpck_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = this(value);
/******/ 		if(mode & 8) return value;
/******/ 		if(typeof value === 'object' && value) {
/******/ 			if((mode & 4) && value.__esModule) return value;
/******/ 			if((mode & 16) && typeof value.then === 'function') return value;
/******/ 		}
/******/ 		var ns = Object.create(null);
/******/ 		__nccwpck_require__.r(ns);
/******/ 		var def = {};
/******/ 		leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 		for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 			Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 		}
/******/ 		def['default'] = () => (value);
/******/ 		__nccwpck_require__.d(ns, def);
/******/ 		return ns;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nccwpck_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/ensure chunk */
/******/ (() => {
/******/ 	__nccwpck_require__.f = {};
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__nccwpck_require__.e = (chunkId) => {
/******/ 		return Promise.all(Object.keys(__nccwpck_require__.f).reduce((promises, key) => {
/******/ 			__nccwpck_require__.f[key](chunkId, promises);
/******/ 			return promises;
/******/ 		}, []));
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__nccwpck_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".index.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nccwpck_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__nccwpck_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/compat */
/******/ 
/******/ if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0, -1) + "/";
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	// no baseURI
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		179: 0
/******/ 	};
/******/ 	
/******/ 	var installChunk = (data) => {
/******/ 		var {ids, modules, runtime} = data;
/******/ 		// add "modules" to the modules object,
/******/ 		// then flag all "ids" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0;
/******/ 		for(moduleId in modules) {
/******/ 			if(__nccwpck_require__.o(modules, moduleId)) {
/******/ 				__nccwpck_require__.m[moduleId] = modules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(runtime) runtime(__nccwpck_require__);
/******/ 		for(;i < ids.length; i++) {
/******/ 			chunkId = ids[i];
/******/ 			if(__nccwpck_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				installedChunks[chunkId][0]();
/******/ 			}
/******/ 			installedChunks[ids[i]] = 0;
/******/ 		}
/******/ 	
/******/ 	}
/******/ 	
/******/ 	__nccwpck_require__.f.j = (chunkId, promises) => {
/******/ 			// import() chunk loading for javascript
/******/ 			var installedChunkData = __nccwpck_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 	
/******/ 				// a Promise means "currently loading".
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[1]);
/******/ 				} else {
/******/ 					if(true) { // all chunks have JS
/******/ 						// setup Promise in chunk cache
/******/ 						var promise = import("./" + __nccwpck_require__.u(chunkId)).then(installChunk, (e) => {
/******/ 							if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;
/******/ 							throw e;
/******/ 						});
/******/ 						var promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])
/******/ 						promises.push(installedChunkData[1] = promise);
/******/ 					} else installedChunks[chunkId] = 0;
/******/ 				}
/******/ 			}
/******/ 	};
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module used 'module' so it can't be inlined
/******/ var __webpack_exports__ = __nccwpck_require__(390);
/******/ __webpack_exports__ = await __webpack_exports__;
/******/ var __webpack_exports__default = __webpack_exports__.Z;
/******/ export { __webpack_exports__default as default };
/******/ 
